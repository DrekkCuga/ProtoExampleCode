#!/usr/bin/env python3
#Version 1.1
import sounddevice as sd
import numpy as np
from PIL import Image, ImageOps
import time
import math
import random
import os
from rgbmatrix import RGBMatrix, RGBMatrixOptions

# vars
matrix = None

DO_AUTO_BLINKS = True

sd.default.device = 0  # 0 is USB boi
FRAME_WIDTH = 64
FRAME_HEIGHT = 16
col = [255, 0, 255]  # Color of pixels
voice_counter = 0
maxvol = 0
last_voice_state = 0
current_voice_state = 0
current_eye_state = 0
stream = None
update_ready = True

blink_time = 0.2
blink_timer = time.perf_counter()


eyearray = [
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00,
     0x1F, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00],  # 1
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0x00, 0x00,
     0x1F, 0xFF, 0xFF, 0xF3, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00],  # 2
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x1F, 0xFF, 0xF0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xFF, 0x8E, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xFF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00],  # 3
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x1F, 0xE0, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00],  # 4
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x1C, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x80, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x07, 0xF8, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFE, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00],  # 5
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x1C, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00],  # 6
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x1C, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00],  # 7
]
moutharray = [
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x01, 0xF0, 0x00, 0x38, 0x07, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x7C, 0x0F, 0x80, 0x00, 0x00, 0x00, 0x0F, 0xC0, 0xEE, 0x1C, 0xC0, 0x00, 0x00, 0x00, 0x01, 0xF9, 0xC7, 0x38, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x83, 0xF0, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0xE0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],  # 1
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x06, 0x00, 0x00,
     0x00, 0x00, 0xF0, 0x00, 0x7C, 0x0F, 0x80, 0x00, 0x00, 0x00, 0x1E, 0x00, 0xFE, 0x1F, 0xC0, 0x00, 0x00, 0x00, 0x0F, 0xC1, 0xEF, 0x3C, 0xF0, 0x00, 0x00, 0x00, 0x01, 0xFB, 0xC7, 0xF8, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x83, 0xF0, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0xE0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],  # 2
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x0F, 0x80, 0x00,
     0x00, 0x00, 0x30, 0x00, 0xFE, 0x1F, 0xC0, 0x00, 0x00, 0x00, 0x1E, 0x01, 0xFF, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x0F, 0xC3, 0xEF, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xC7, 0xF8, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x83, 0xF0, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0xE0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],  # 3
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x0F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x1F, 0xC0, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xFF, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x0E, 0x01, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x0F, 0xFF, 0xEF, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xC7, 0xF8, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x83, 0xF0, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0xE0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],  # 4
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x0F, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x1F, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x3F, 0xF0, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x02, 0x01, 0xFF, 0xFF, 0xF8, 0x00, 0x00, 0x00, 0x07, 0xFF, 0xEF, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x01, 0xFF, 0xC7, 0xF8, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x83, 0xF0, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x06, 0x01, 0xE0, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],  # 5
]

# Functions down here

# Split a frame into its rows


def arrayToImg(arr, width, height, col=[255, 0, 255]):
    imgArray = []
    if len(arr) == width*height / 8:  # single-color mode
        counter = 0
        row = []
        for byte in arr:
            for i in range(8):
                bit = byte >> 7-i & 1
                pixel = col if bit else [0, 0, 0]
                row.append(pixel)
            counter += 8

            if counter % width == 0:
                imgArray.append(row)
                row = []
    else:  # RGB mode
        counter = 0
        row = []
        for i in range(int(len(arr)/3)):
            r = arr[i*3]
            g = arr[i*3+1]
            b = arr[i*3+2]
            row.append([r, g, b])
            counter += 1

            if counter % width == 0:
                imgArray.append(row)
                row = []
    return Image.fromarray(np.uint8(imgArray)).convert("RGB")


def generateFace(eyeIndex, mouthIndex, width, height):
    halfHeight = int(height/2)
    mouthImg = arrayToImg(moutharray[mouthIndex], width, halfHeight, col)
    eyeImg = arrayToImg(eyearray[eyeIndex], width, halfHeight, col)
    # Create image with size of both panels
    img_out = Image.new('RGB', (width, height))
    # Gotta mirror one to make them face the right way
    img_out.paste(mouthImg, (0, halfHeight))
    img_out.paste(eyeImg, (0, 0))
    return img_out


def reflectImg(img):  # Reflect image so that it displays correctly on both panels
    img_out = Image.new('RGB', (img.width*2, img.height))
    img_out.paste(ImageOps.mirror(img), (img.width, 0))
    img_out.paste(img, (0, 0))
    return img_out


def sound_callback(indata, frames, time, status):
    global voice_counter
    global maxvol
    global last_voice_state
    global update_ready
    global current_voice_state
    if voice_counter % 5 == 0:
        state = 0
        if maxvol < 5:
            state = 0
        elif maxvol < 10:
            state = 1
        elif maxvol < 15:
            state = 2
        elif maxvol < 20:
            state = 3
        else:
            state = 4
        maxvol = 0
        if state != last_voice_state:
            current_voice_state = state
            update_ready = True
            last_voice_state = state
    else:
        volume_norm = int(np.linalg.norm(indata)*10)
        if volume_norm > maxvol:
            maxvol = volume_norm
    voice_counter += 1


def init():
    global stream
    global matrix
    global ring_thread
    stream = sd.InputStream(callback=sound_callback, device="usb", channels=1)
    stream.start()

    options = RGBMatrixOptions()
    options.rows = 32
    options.cols = 64
    options.chain_length = 2
    options.parallel = 1
    options.gpio_slowdown = 2
    options.hardware_mapping = 'adafruit-hat'
    matrix = RGBMatrix(options=options)

# Manually queue a blink for now


def start_blink():
    global blink_timer
    blink_timer = time.perf_counter()

# Calculate and check the current blink frames, allows for animations without a sleep command


def do_blink_update():
    global blink_timer
    global current_eye_state
    global update_ready
    global DO_AUTO_BLINKS
    # How many frames in the animation, 0 index'd for array access
    blink_frames = len(eyearray)-1
    # Time since the start of the animation, goes negative if we haven't started yet
    time_since_start = time.perf_counter() - blink_timer
    if time_since_start < 0:  # So we can queue blinks without things getting weird
        return
    interval = blink_time / blink_frames  # Interval between frames
    # Turn the time since start into the frame number with specified interval
    frame_counter = int(
        (math.floor(time_since_start*(1/interval))/(1/interval))/interval)
    real_frame = 0  # Because we play it backwards afterwards, keep track of the real frame that we want to show

    # First loop forward, 2nd backward then nothing
    if frame_counter < blink_frames:  # Going forward
        real_frame = frame_counter
    elif frame_counter < blink_frames*2:  # Going backward
        # count back down instaid of up
        real_frame = blink_frames - frame_counter % blink_frames
    elif frame_counter > blink_frames*2:  # Animation is done
        real_frame = 0
        if DO_AUTO_BLINKS:  # If we are using auto-blinks, queue next blink
            blink_timer = time.perf_counter() + (random.randint(50, 70)/10)
    else:  # Incase things get weird
        real_frame = 0

    # if we have a new frame, queue update
    if current_eye_state != real_frame:
        current_eye_state = real_frame
        update_ready = True  # Tell main loop we have a new frame to display


def loop():
    global update_ready
    global current_voice_state
    global current_eye_state
    do_blink_update()  # Run blink updater
    if not update_ready:
        return
    img = generateFace(current_eye_state, current_voice_state, 64, 32)
    matrix.SetImage(reflectImg(img))  # Show em
    update_ready = False  # Mark that we have finished with this update
    pass


if __name__ == "__main__":
    init()
    while True:
        loop()
